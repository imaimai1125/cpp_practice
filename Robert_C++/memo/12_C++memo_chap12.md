## chapter.12 もっともっと高く
発展的な内容（クラスを使うこと以外の発展的な内容）
## 11/5 p566-
- 12.1-12.3  ビット演算
- 12.4-12.5 ビットフラグ
- 12.6 インライン関数
- 12.7 インラインメンバ関数
- 12.8-12.9 typedef
- 12.10 マクロ
- 12.11 マクロの使い方
- 12.12 マクロが原因のバグ
- 12.13 assertマクロ
- 12.14 デバッグモードとリリースモード

### 12.1-12.3 ビット演算 
- **AND**は論理積。```&```であらわす。
	- -特定のビットを取り出すときに使う
		- 消したいところのビットを0にした値を使って論理積にかけると良い（**masking**）
	- ビット演算子は四則演算とかに比べて優先順位が低い
		- 関係演算子（<=>など）よりも低い
		- 例外として NOT（```~```）は優先順位が高い
- **OR**は論理和。それぞれのビットについて両方共0のときは0，それ以外のときは1を出力
	- ORは```|```で表す
	- ORはビット合成するときに使う
- **XOR**は排他的論理和。それぞれのビットについて両方が同じ時は0、異なるときは1を出力
	- ORのうち、両方が重なるところを除外している
	- 特定のビットを**反転**させる時に用いられる
	- XORは```^```で表す
```
//プレイヤー切り替え 0 or 1
player ^= 1;
```
- **NOT**は論理否定。```~```で表す
	- 全ビットを反転する
- **ビットシフト** ```<<```もしくは ```>>```で表す。
	- 2の累乗の掛け算、割り算（及びあまり）に対応している。
	- 負の数を右シフトするとビットのなくなってしまうところが1で埋められる（算術シフト（環境依存）） 

- 補数（負の数）
	- 10を二進数で表すと(0001010)2となる
	- 補数は(11110110)2となる（反転して1をたす）

### 12.4-12.5 ビットフラグ（bool型のようなもの）
ビット演算の花型

- ビットフラグは```OR```で**つなぐ**
- ビットフラグは```AND```で**判定**する
- ビットフラグは```OR```で**合成・追加**できる
- ビットフラグは```NAND```で**削除**できる
- ビットフラグは```XOR```で**反転**できる

```
#include <iostream>
using namespace std;

int Bit(int x){
	return 1 << x;
}

//それぞれの記号の反転器
const int SHぽあOW_X = Bit(0);
const int SHOW_Y = Bit(1);
const int SHOW_Z = Bit(2);
//結果を表示
void Show(int flags){
	cout << ((flags & SHOW_X) != 0 ? "X" :"x")
		 << ((flags & SHOW_Y) != 0 ? "Y" :"y")
		 << ((flags & SHOW_Z) != 0 ? "Z" :"z")
		 << endl;
}
int main(){
	//Showの引数はどのビットが立つかを記述している。
	//ひとけた目がX...となっている
	Show(1);
	Show(SHOW_X);
	Show(SHOW_X|SHOW_Z);
	Show(SHOW_X|SHOW_Y|SHOW_Z);
}
```

### 12.6 インライン関数
- 関数を呼ぶには時間がかかる
	- その関数が置かれているメモリ上の場所に移動しなければいけない
	- 関数の中身を関数に埋め込んでいる
	- ```inline int func(){} ```とする。
- インライン関数はライン関数を使うと処理をその場所に埋め込める
- インライン関数は**ヘッダファイルで実装***する
- インライン関数は必ず展開されるとは限らない
	- 処理が重いものはコンパイルが自動判断して普通の関数にしちゃう
- インライン関数内の静的ローカル関数はすべての展開先で同一のものが作られる。

### 12.7 インラインメンバ関数
- メンバ関数もインライン関数にできる
- **クラスの宣言の中で実装**するとインライン関数になる。
	- この場合は```inline```と記述しなくてよい
```
class Fraction{
public:
	//分子の取得
	//クラス宣言時に実装
	double GetNumber() const{
		return m_numer;
	}
}
```
- テンプレートの場合に限りクラス宣言内で実装する人もいる
	-常にヘッダファイルに実装を書く必要があるので、クラス宣言内で実装してしまっても特に問題がない。

## 11/6
### 12.8-12.9 typedef
- typedefを使うと型の同義語を作ることができる。
- 変数の宣言文の頭にtypedefをつけると変数ではなくその型の同義語がつくれる
- ポインタ型の同義語にconstをつけるとポインタ自身のみが定数になる
```
typedef int* IntPtr
//↓参照にconstをつけるならこうしなければいけない。
typedef const int* IntPtr
```

### 12.10-12.11 マクロ
- マクロはテキストを指定した位置に差し込むもの
- テキストが差し込まれてから、そのあとにコンパイルが行われる
- マクロは**引数**も取れる(関数型のマクロもOK)
```
#include <iostream>
using namespace std;

#define FIVE_TIMES for(int i_ = 0; i_ < 5; ++i_)

int main(){
	FIVE_TIMES{
		cout << i_+1 << " Hello" << endl;
	}
}
```
- マクロを使えば変数や関数などにはできないがよく使う処理を**共通化**できる

### 12.12 マクロの正しい使い方
- マクロ名とマクロ引数のカッコの間に空白を入れてはダメ
- 複文をマクロにしたい場合はその複文を{}あるいは```do {} while(false)```で囲む（ブロックという）
- マクロ引数や差し込まれるテキスト全体は可能な限りカッコで囲む
```
#define MUL(a,b) a*b
//↓
#define MUL(a,b) ((a)*(b))
```
- マクロ引数を2度以上使用するマクロには2度以上実行されては困るものを渡さない
	- できるだけインライン関数や関数テンプレートを使って処理しよう。
- マクロ定義内で改行したいときは文の終わりに ```\``` をつける
- 複数行マクロの途中にコメントをつける場合は必ずブロックコメントを使用する
- マクロの有効範囲は定義されてからソースファイルの最後まで
- ```#undef マクロ名```で定義したマクロを無効にできる

### 12.13 assertマクロ
- ```#include<cassert>``` 
- assert(条件式) とすると条件式が偽のときにプログラムが強制終了する
- assertマクロはNDEBUGマクロが定義されていると消えてなくなる
- ポインタがNULL：```assert(p!=NULL);```
- 変数nが0以上：```assert(n>=0);```

### 12.14  デバッグモードとリリースモード
- 多くの開発環境ではデバッグモードとリリースモードが用意されている
- リリースモードでコンパイルするときに事前にNDEBUGマクロが定義されるようにすることができる。
```
g++ -c -DNDEBUG Hello.cpp
```

### memo
- あとでmakefileの作り方一気に勉強する。**（p624-p629）**
