
## chapter.8  ファイルとストリーム
## 11/2 

- 8.1-8.2 stringクラス
- 8.3 stringstreamクラス
- 8.4-8.5 ファイルのすすめ
- 8.6 テキストとバイナリ
- 8.7 2進数・16進数
- 8.8 バイナリモードで読み書き
- 8.9 ファイル操作のエラー処理
- 8.10 ファイルポインタ
- 8.11 iostreamとマニピュレータ
- 8.12-8.14 名前空間

### 8.1-8.2 stringクラス
- stringクラスを使えば文字列を便利に扱える
- c_strメンバ関数を呼ぶとconst char 配列のアドレスが得られる
- ```string hello = "Hello";```は```string hello("Hello");```とほとんど同じ
- stringは```hello += " World"```のようなことができる（演算子オーバーロードを使っている）
- ```getline``` は入力から一行拾い、stringクラスのオブジェクトに入れる関数。
- 引数に指定した文字列をlineの**末尾**から検索していく関数。

```
string::size_type pos = line.rfind(".");
```
- 見つかった場合はそのインデックスを、見つからなかった場合は```string::npos```（```::```はスコープを返す）
- string型にはたくさんのメンバ関数が用意されているので、必要に応じて使う**（p378-379）**
	- i番目の要素への参照を返す(```char& operator[](string::size_type i)  const char& operator[](string::size_type i) const;```)
	- 文字列のサイズ変更(```void resize(string::size_type n)```)
	- 文字列を空に（```void clear```)
	- などなど。

### 8.3 stringstreamクラス
- stringstreamクラスを使えばcoutと同じ形で文字列生成ができる
- stringstreamクラスを使えばcinと同じ形で文字列から値を取り出すことができる。
- stringstreamクラスは<sstream>内にある
- stringstream内に残っている文字列を一旦消去 -> ```sstr.str(" ")```


## 11/3 p385-
### 8.4-8.5 ファイル操作の基本
- ```<fstream>```を使う、
- ファイルを使うにはファイルを開く必要あり！
- ファイルを使ったらきちんと閉じよう!

```
#include <iostream>
//ファイルの取り扱い
#include <fstream>
//
#include <cstdlib>
using namespace std;

int main(int argc, char const *argv[])
{
	fstream file;
	//書き出し用のフラグios::out
	file.open("8_4_test.txt",ios::out);
	//ファイルが開けるかどうかの確認
	if(! file.is_open()){
		return EXIT_FAILURE;
	}
	//ファイルへの書き込み
	file << "ファイルに書き込んじゃいますね？？？" << endl;
	file.close();
}
```

- 読み込みを行うには読み込みのための場所を用意する（stringなど）
- 読み込み用のフラグは```ios::in```、書き出し用は```ios::out```
	- ```ios::binary```	バイナリモードで開く (binary)
	- ```ios::trunc```	ファイルが存在していた場合、その内容を破棄してから開く(truncate)
	- ```ios::app```	常にファイルの末尾に書き出す(append)
	- ```ios::ate```	ファイルを開いたあとファイルの末尾に移動(at end)


### 8.6 テキストとバイナリ
- ファイルの中身は1バイト単位のデータがメモリと同じように詰まっているだけ
- ファイルの内容を変換するモードにはバイナリモードとテキストモードの2種類がある
- テキストモードでは改行が```\n```として呼び出されOSに合わせた形で書き込まれる
- ファイルに本質的にバイナリやテキストの区別があるわけではない。
- テキストモードとバイナリモードの違いは改行コードの取り扱いだけ

### 8.7 2進数と16進数
- 16進数なら2進数を意識したプログラムが組みやすい
- プログラム上で16進定数を定義するときは頭に**0x**をつける
- プログラム上で8進定数を定義するときは頭に**0**をつける

### 8.8 バイナリモードでの読み書き
- ナマのデータはwriteで書き込む
- ナマのデータはreadで読みだす
- ナマのデータの表現方法は環境によって変わる
- ファイルに書き込むときの方法は2種類
	- データを文字にして書き込み、書き込んだあとのファイルを読めるようにする方法 ```file << "aaaaa"```
	- メモリ上のデータをそのまま書き込む方法 ```file.write(const char*(0x1111111))```
- write(,)とread -> 第一引数は先頭アドレス、第二引数は変数のバイト数

### 8.9 ファイル操作のエラー処理
- ```file.gcount()~`` 	: 何バイト読み込まれたかを取得できる
- ```file.eof()```		: end of file ファイルの最後に到達した時に**TRUE**を返す
- ```fail```を用いるとファイル操作に失敗したかどうかがわかる
- ファイル操作時のエラーを考えながらプログラムを組むことは重要

### 8.10 ファイルポインタ
- ファイル名の取得・ページ送りなどが可能に！！
- ファイルの操作位置を**ファイルポインタ**という
- seekgメンバ関数やseekpメンバ関数でファイルポインタの位置を変更できる。
- tellgメンバ関数やtellpメンバ関数でファイルポインタの位置を取得できる。
- ```m_file.seekg(m)```先頭からｍ番目の位置にポインタを当てる
	-使えるフラグ
	-```ios::beg``` ：ファイルの先頭から数える
	-```ios::end``` ：現在いる位置から数える
	-```ios::cur``` ：ファイルの末尾から数える

- ```m_file.clear()``` ファイルへのアクセスを再度可能にするための関数


### 8.11 iostreamとマニピュレータ
- ストリームとは効率のよい入出力機構
- istreamはストリーム入力を、ostreamはストリーム出力を行うクラス（どちらもiosの派生クラス）
- iostreamはistreamとostreamの派生クラス
- stringstreamやfstreamはiostreamの派生クラス
- iomanipヘッダには入出力を制御するマニピュレータが用意されている。**（p425）**


### 8.12-8.14 名前空間
- ```namespace 名前空間名{}``` その中の識別子はその名前空間に属するようになる。
- ある名前空間に属する名前は ```名前空間名::識別子```のように使う
- 名前空間を自分で指定していなかった場合、その識別子は**グローバル名前空間に属する**
- グローバル名前空間に属する識別子は```識別子```または```::識別子```とかく
- 変数・関数の寿命を決めて、それを解決するスコープ演算子のようなもの
- 名前空間の指定を省略したいときは ```using namespace 名前空間名;```とかく
- 特定の識別子の名前空間指定を省略するときは```using 名前空間::識別子;```とかく
- ```namespace 別名 = 名前空間名;```とすると、名前に別名を与えられる
- usingをヘッダファイルでは使わないようにする。というかなるべく使わないようにしておこう。
- std::を付けなくてもいいものはマクロという（12章）
- 同じ名前空間内の名前は**名前空間内の指定なし**に使える
- グローバル名前空間内にある名前と衝突した場合、**現在の名前空間内の名前が優先される**
- 名前空間は複数の箇所に分割することができる。


### memo
- 演算子オーバーロードのことは正直よくわかってない
- 同じくコピーコンストラクタもイマイチ
- クラスを複数作るときの初期化と代入について不都合なく処理を行うための手続き？？
- bool代数とwhileは相性がよさ気
