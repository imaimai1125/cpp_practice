## chapter.14 もっともっと深く
クラスとは関係が浅い事項に関すること


- 14.1 ショートサーキット
- 14.2 voidへのポインタ
- 14.3-14.4 if
- 14.5 組み込みマクロ
- 14.6 可変個引数
- 14.7 mainの戻り値
- 14.8 コマンドライン引数
- 14.9 強制終了
- 14.10 アラインメント
- 14.11 プリコンパイル済みヘッダファイル

## 11/13 p720-
### 14.1 ショートサーキット		
- もとからC++に備わっている仕様
- 条件式は真か偽かが判明したところですぐに判定を終了する．
	- 人間は鳥であり，かつ人間は虫である．
	- 人間は鳥である，**かつ**で終了したい->ショートカットサーキット
- ショートカットサーキットが原因で起こってしまうバグだってある
- 省略された条件内の関数は呼ばれない


### 14.2 voidへのポインタ
voidに*をつけるとどうなるの？？？
- voidへのポインタにはほとんどのポインタをキャストなしで代入できる
- voidへのポインタからは直接は参照先にアクセスできない
- voidへのポインタから他のポインタへの代入にはキャストが必要	
- voidへのポインタは型を不問でアドレスを受け取る引数に使う

## 11/14 p728-
### 14.3-14.4 #if
- `#if 条件式 〜 #endif`でコンパイルするかどうかを制御できる
	- `#`は前処理命令と言って，コンパイルする前にいろいろと操作するための命令
	- `#if`のあとの条件式が真のときのみ`#endif`までコンパイルせよということ
- 定義されているかの評価は`defined(名前)`で行える．`#if`特有の演算子
- マクロが定義されているかどうかの分岐には`#ifdef`とか`#ifndef`とかが用意されている
	- 二重インクルード防止のときとかに使った(if defined / if not defined)
- elseやelse if に対応するものとして`#else`とか`#elif`がある
- `#if`の条件式にはコンパイル前に決まる値しか使うことができない
- `#error`を使うと強制的にコンパイルエラーを出すことができる．
```
//DEBUGのつぎに書いた文はデバッグ時にのみ実行
#ifdef NDEBUG
#define DEBUG if(true){}
#else
#define DEBUG is (false){}
#endif
...

DEBUG Hoge(1,2);
//↑はデバッグ時にしか実行されない
```

### 14.5 組み込みマクロ
12.13節のassertマクロを自作してみる
- `_FILE_`はファイル名，`_LINE_`は行番号に置き換わる
	- これがマクロ定義内出会っても，展開先の情報で展開される

- 組み込みマクロの種類
	- `__FILE__` : ファイル名を表す文字列リテラル
	- `__LINE__` : 行番号を示す10進定数
	- `__DATE__` : 現在のソースファイルをコンパイルしたときの日付を表す文字列リテラル
	- `__TIME__` : 現在のソースファイルをコンパイルしたときの時刻を表す文字列リテラル
	- `__cplusplus__` : C++のコンパイラでコンパイルされた場合に定義される
	- `__STDC__` : これが定義されているかどうかと，定義され値た場合のその値は処理系定義

### 14.6 可変個引数
- 引数の部分を...にすればいくらでも引数が取れる
- va_list型の変数とva_start, va_arg, va_endマクロで可変個引数を扱える
- 注意３つ
	- 可変個引数に渡す際，必ず元の型が保存されないという点 : 引数に渡したchar値とshort値はint値に，float値はdouble値にそれぞれ自動的に拡張される
	- 可変個引数に渡されてきた値の型や引数の数は取得できない : 可変個引数の個数は言語的にはどうやっても取得できないので関数を使う人が注意すべき
	- ポインタの扱い : NULL pointer は必ず適切なポインタ型にキャストしてから渡す．

```
void PrintF(const char* format,...){
	va_list args;
	va_start(args,format);
	vprintf(format, args);
	va_end(args);
}
```

## 11/16 p746-
### 14.7 mainの戻り値

EXIT_FAILUREとかってなんなの？
プログラムの終わりの部分のお話
- mainの復習
	- プログラムはmainから実行される(厳密にはグローバル関数の初期化処理から始まっているが．)
	- mainも関数の一つ：returnを持つ
- main関数終了後は全静的変数の終了処理が実行される．そういう処理を行っているルーチンが内部的に存在している．（startup routine)
	- startup routine はmainの終了後mainの戻り値を受けて各種終了処理を行う．
```
//概念的には...
void Startup(){
	Initialize();
	exit(main());
}
```
- main関数の戻り値が`EXIT_SUCCESS(0)`の場合は正常終了，`EXIT_FAILURE(1)`
の場合は異常終了をあらわす．
- main関数の戻り値を省略した場合はEXIT_SUCCESSから自動的に返される
	- その終了状態はプログラムを実行した存在へと**環境依存**な形で返される
- system関数でプログラムを実行できる
  
### 14.8 コマンドライン引数	
プログラムの最初の部分のお話

- プログラムに渡す文字列lsをコマンドライン引数という
- コマンドライン引数はint main(int argc, char** arg v)のようにしてmain関数の引数で受け取る．
	- こいつらはコマンドライン専用の引数
	- 基本的に`argc`はコマンドライン引数の個数
	- 基本的に`argv`はコマンドライン引数（文字列）の配列になっている．
	- ただし，`argv[0]`はファイルの場所がはいるので，実際の引数の個数+1
	となっている．
- IDEとかを使っている場合は環境ごとに設定方法がある (p754-p757)

### 14.9 強制終了
使わざるを得ない時にだけ使う最終手段

- `exit`か`abort`で強制終了できる
	- `exit`は終了処理を行う,引数を持っている
	- `exit`は自動変数のデストラクタは無視（あくまでmain関数後の終了処理だけ行う）
	-`abort`はいきなり打ち切る（デストラクタが呼ばれない），引数を持っていない
- `atexit`を使うと終了処理を自分で追加できる

### 14.10 アラインメント
構造体のサイズを確認したりファイルに保存した時にやけにサイズが大きかったりゴミが保存されたりする理由

- 構造体やクラスのメンバ変数はきっちり詰まっていないことがある(アドレス？？)
	- 詰め物(padding)がある可能性
	- 環境依存なので注意が必要
	- 32ビット気はメモリにアクセスする時4ばいと単位でアクセスする．４バイト境界をまたぐデータを扱うためにはメモリに２回もアクセスしないといけないために面倒．
	- このため，バイト境界でallignしている．
- 構造体の先頭からのメンバ変数の位置は`offsetof`マクロで取得可能
- `#pragma pack`でアラインメントを変更できることがある．
	- `#pragma pack(1)`：バイト境界の最大値が1ということ

```
#include <iostream>
using namespace std;

int main(int argc, char const *argv[])
{
	cout << "argc = " << argc << endl;
	for (int i = 0; i < argc; ++i){
		cout << "argv[" << i << "] = " << argv[i] << endl;	
	}
	return 0;
}
```
### 14.11 プリコンパイル済みヘッダファイル
- 滅多に変更しないヘッダファイルのインクルード時間を節約するために，ヘッダファイルをあらかじめコンパイルしておくことができる**場合がある**
- terminalで`g++ 14_11_Pch.h`と入力すると`14_11_Pch.h.gch`ができた
	- 14_11_Pch.hをインクルードすると，コンパイル済みのやつが使われる

## memo 
- assertマクロ覚えてないな。再チェックしよう
- 変数とスタック：自動変数や引数はスタックというメモリ領域に作られる．引数は**最後の引数から順番に**スタックに積まれていく．一番最初の引数がスタックに積まれたあとにかん数から戻るときに**ジャンプする位置のアドレス（return address)をスタックに積んで関数へとジャンプする**．こうすると，スタックの一番↑にはリターンアドレスがあり，そのつぎに積まれているものが一番最初の引数だとわかる．そしてそのつぎのメモリ領域からがかへの引数のメモリ領域であるとわかる
- va_start買う路はこの可変個引数のメモリ領域の先頭アドレスをva_list型の変数にセットする．

- マクロで↓みたいなの定義できると環境に応じていろいろな設定ができるから便利だなと思いました．
```
#ifdef WINDOWS
#define CURRENT
#else 
#define CURRENT "./"
#endif //WINDOWS

```
- p773-775はmakefileの作り方なので**後で読む**
	- Release, debugとかもちゃんと後で読まないとなと思っている．

