## chapter.9 テンプレート
## 11/4 441-

処理を共通化する（型とか）

- 9.1-9.5 関数テンプレートの基礎
- 9.6-9.7 クラステンプレート
- 9.8 デフォルトテンプレート引数
- 9.9 便利な配列 vector

### 9.1-9.5 関数テンプレート
- 関数テンプレートは形は同じだけど型だけが違う関数をひとまとめにしたもの
- ```template <テンプレート引数>```が定義の頭につく
- templateにしておけば曖昧な型にしておける
- ```typename 型名```は型名が何らかの型であることを宣言するもの 
- 同じ型名の型はすべておなじ型になる

```
template <typename TYPE>
 TYPE Abs(TYPE a)
 {
 	return a < 0 ? -a:a;
 }

 int main(){
 	cout << Abs(-10) << endl;
 	cout << Abs(-1.5) << endl;
 }
```

- テンプレート引数は必要に応じて何個でも作れる。
- 関数テンプレートは型に合わせた**実体を適宜作る**
	- 関数テンプレートは鋳型みたいなもの。一つの型につき一つの実体が生まれる。
	- 継承は実体を**一個**しか作らない
- 関数テンプレートの実装は実体を作るところから見えなくてはならない
- 関数テンプレートの実装はヘッダファイルに書いておく
- テンプレートは書かれた処理が実行可能でさえあればどんな型でも受け入れる。
	- 型ごとに実体が作られるのでどの呼出でどの実体が呼ばれるかは静的に決定される
- アップキャストを利用した関数はある基底クラス・そこから派生したクラスのオブジェクトしか引数に取れない
	- 関数の実体は一つでよく、どの呼出でどのオブジェクトに関する動作が行われるかを動的に決定できる
	- 処理の異なる部分を仮想関数にしておかないといけない。
- 関数テンプレートを呼ぶときにテンプレート実引数を指定することができる
- テンプレート実引数は関数テンプレート名のあとに<>で囲んで書く
- テンプレート引数にはクラスも指定できる（stringとか）
- 指定した処理が実行できなければコンパイルに失敗する（string型で足し算とかはエラーになる）


### 9.6-9.7クラステンプレート
- クラスのテンプレートも作ることができる。
- クラスの処理は同じだけどその中の型とか違うときにテンプレートはとても便利！
- templateはクラス宣言の前と各メンバ関数の実装の前の**全て**につける。
- クラステンプレートは**明示的**にテンプレート引数を指定して使う
	- 自動的に判断するのは難しいのではじめから判断できないようにしている。
```
Array<double> array(10);
```
- メンバ関数の実装時にはクラス名にテンプレート引数を指定する
- デフォルトテンプレート ```template <typename TYPE = char>```
	- 引数を省略した時にある特定の値を引数に取るようにするもの。
	- 関数テンプレートの場合はデフォルトテンプレートを取ることはできない

### vector::
- vectorクラステンプレートを使えば配列が簡単に扱える
- ```vector<double> v(10);```
	- v.resize(5) 配列のサイズを5にリサイズ
	- あたかも普通の配列であるかのように扱うことができる
	- 様々なメンバ関数を持っている**（p471-472）** 