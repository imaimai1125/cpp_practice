3＃＃＃＃＃## chapter.11 もっと高く
発展的な内容になっていく
## 11/5 p512-

- 11.1−11.2 静的メンバ変数 
- 11.3-11.4 静的メンバ定数
- 11.5 メンバ定数（静的でない）
- 11.6-11.7 テンポラリオブジェクト
- 11.8 戻り値の型が参照な関数と演算子オーバーロード
- 11.9 代入式を利用した演算
- 11.10 演算子オーバーロードとthis
- 11.11 クラス外での演算子オーバーロード
- 11.12 暗黙のキャストとその抑制
- 11.13 C++のキャスト

### 11.1-11.2 静的メンバ変数
- メンバ変数に staticをつけると静的変数になる
- 静的メンバ変数はどれだけクラスを作っても**共有**される
- 静的メンバ変数は実体を別に**宣言**する必要がある。
- 静的メンバ変数は実体の定義の部分で初期化する
- 静的メンバ変数は**全実体で内容を共有したい**ときに使う
- 派生しても静的メンバ変数は1個

### 11.3 静的メンバ関数
- 静的メンバ関数は**実体がなくても呼べる**
- 静的メンバ関数は静的メンバ変数しか使えない
- 静的メンバ関数を呼ぶには```クラス名::静的メンバ関数()```
- 静的でないメンバ関数と静的なメンバ関数の違い
	- 静的：実体のアｈあドレスが渡されない。実体がなくても呼べる。(いちいち実体を作らなくてもクラスへのスコープで呼べる)
	- 静的でない：呼ぶときに使った実体の**アドレス**が渡される

### 11.4 静的メンバ定数
- **整数**の静的メンバ定数は**直接初期化**できる
	- そうしないとconstの値が実体を持てない。staticは実体を持たないことを許すからよく解んなくなる。
- 静的メンバ定数以外では直接初期化はできない。

### 11.5 メンバ定数
- 静的でないメンバ定数はつくれる？？->作れる
- メンバ定数には代入不可能
- メンバ定数はコンストラクトの初期化子で初期化できる。
	- コピーコンストラクタとかではどうなの？？？

### 11.6-11.7 テンポラリオブジェクト
- コンストラクタを直接呼ぶ感じにすればテンポラリオブジェクトを作ることができる
```
throw exception();

str = string("Hoge");
str = (string)"Hoge"; //<-キャストの形（引数が1つの場合限定）
クラス名（実引数リスト)
```
- テンポラリオブジェクトの寿命はその文が終わるまで。
	- 文の終わりとは；命令文一行とか。たとえば代入が終わったら破棄される
- オブジェクトを返す関数もテンポラリオブジェクトを作る
- const参照に普通の値を入れるとテンポラリオブジェクトが作られる

```
int Abs(const int &a){
	return a<0 ? -a:a;
}
int main(){
	//このあとAbs(-10)は死ぬ
	cout << Abs(-10) << endl;
}
```
- const参照にテンポラリオブジェクトを入れると寿命が伸びる
	- いまいちよくわからない。。。	



### 11.8 戻り値の値が参照な関数と演算子オーバーロード
- 参照を返す関数を使えば関数の戻り値への代入などが行える
```
//参照を戻り値にすることでセットとゲットをひとまとめにできる
int& IntArray::At(int i){
	CheckIndex(i);
	return m_array[i];
}

```

- ポインタや参照を返す関数では変数の寿命に注意する
	- テンポラリオブジェクトは文が終わったあとに死ぬけど、参照は残ったままなので、死んだ場所を参照することになっちゃう
	- dangling referenceという
- あるものを使いやすくするために作るクラスや関数をラッパ関数(wrapper)という
	- ナマの値や関数を隠し代わりに便利な操作をする
- 演算子オーバーロード```戻り値の型 operator[](インデックス)```
```
int& IntArray::operator[](int i){
	CheckIndex(i);
	return m_array[i];
}

//このとき、v[i]はoperator[](i)と同等の扱いができるようになる！
```

### 11.9 代入式を利用した演算
- いろいろな演算子をオーバーロードしてみる
- 代入式は代入される変数の代わりとして使える
- 代入式の値は代入演算された**あと**の値になる
- 後置インクリメント```i++```は特殊で、代入演算はできず、1増える**前**の値を返す
- ```a = b = 5```とかできる

### 11.10 演算子オーバーロードとthis
- キャスト演算子もオーバーロードできる
- 2項演算子では左項が自分自身に、右項が引数になる
- thisを使うとメンバ関数を呼び出したオブジェクトのアドレスを取得できる
- 後置インクリメントではint型のダミー引数をとる
 
```
Fraction::operator double() const{
	return m_numer/m_denom;
}
//こうすることでf.Get() -> f になる。
```
- メンバ関数を呼ぶのに使ったオブジェクトのアドレスを参照するときは```this```
```
Fraction& Fraction::operator*=(const Fraction &rop){
	m_numer *= rop.m_numer;
	m_denom *= rop.m_denom;
	return *this;
}

```

### 11.11 クラス外での演算子オーバーロード
- クラスが右項に来る場合はクラス外で演算子オーバーロードする
- クラス内でfriendつきの関数プロトタイプを宣言すると、その関数内ではprivateメンバにアクセスできる。この関数をクラスのフレンド関数という。
	- privateの意味がなくなり危険なのでなるべく使わないようにしたい
	- クラス内で宣言するけどあくまで**非メンバ関数**
- =演算子（代入演算子）はクラス外ではオーバーロードできない。
```
ostream& operator<<(ostream& ostr, const Fraction rop){
	ostr << rop.m_numer << " / " << rop.m_denom;
	return ostr;
} 
//こうすればcout << は operator << (cout,f) となり
//自分dね定義した通りに動かせる。
```

### 11.12 暗黙のキャストとその理解
- 引数が一つのコンストラクタがあればそれを利用して暗黙のキャストが行われる
- 引数が2つのコンストラクタの場合でも、デフォルト引数がある場合はキャストされる
- 暗黙のキャストを抑制したい場合はコンストラクタの宣言にexplicitをつける


### 11.13 C++のキャスト
- ()を使ったキャストは3種類に分類できる
	- static_cast 静的な普通の型変換を行う ```b = static_cast<unsigned char>(a);``` としておいたほうが間違いが少ない

	- reinterpret_cast ポインタや参照の関係する強力な型変換 int*からintなど。危ないので注意が必要 ```b = reinterpret_cast<unsigned char*>(a);```
	- const_cast ポインタや参照のconstを外すキャスト
- わざと処理を煩雑にすることで、危険箇所ていうのを目立たせる。

### memo
- 演算子オーバーロードよくわかっていない
- *と&の違いは何？11.10はなぜ&this じゃないの？