## chapter.15 データ構造
- 今までは配列だけだったけど，リスト，スタック，キュー，ツリー，ハッシュ表とかのデータ構造を学ぶ
- 状況に応じていろいろなデータを使い分けることで処理効率が上がったりする

- 15.1 単方向リスト
- 15.2 双方向リスト
- 15.3 イテレータとアルゴリズム
- 15.4 スタックとキュー
- 15.5 placement new
- 15.6-15.8 再帰関数
- 15.9 ツリー
- 15.10 二分木探索
- 15.11 ハッシュ

## 11/17
### 15.1 単方向リスト	
- リストはポインタを介してデータを数珠つなぎしたもの
- リストは配列とは異なり，要素の**挿入や削除が簡単**
- その代わりリストは**インデックスの参照が不得意**

### 15.2 双方向リスト
- 次のノードへのポインンタのみを持つリストをたん方向リストという
	- 指定したノードではなくて，その次のノードを削除するという形にしてあった（不自然）
- 加えて**前の**ノードへのポインタを持つリストを双方向リストという
	- 挿入の際に前後のノードポインタを変更する必要があるけれども，便利にはなる
- リストの端は
	- NULL
	- 端をあらわすダミーのノードをつくる（m_eolなど)
- 代表的なlist関数:**p797-800**
	- T& front/back, resize(size), clear(), empty(), iterator begin/end()
	- iterator insert(), iterator erase() など．．

### 15.3 イテレータとアルゴリズム
リストはノード構造体のメンバに直接アクセスすることでループをしていた
．今回はもっと感覚的に
- ポインタのように扱えるクラスのことをイテレータという
- listヘッダにはリストを扱うクラステンプレート list　が定義されている
- algorithm ヘッダにはイテレータを扱ういろいろな関数テンプレートが定義されている
```
//こっちのほうがわかりやすい	
static void GoNext(Node*& node){
	node node->next;
}
Node::GoNext(node);
```
- こういうノードの処理をラップしたクラスを作れる
- イテレータを扱うことのできる関数テンプレートが標準でいくつも用意されてる--**algorithmライブラリ**
	- fill_n, copy, copy_backward, sort, stable sort, find_if, binary_search, random_shuffle　など
- vectorやlistといったクラステンプレートは複数のデータを統括して使う物(**container**)　
	- コンテナを扱うためのアルゴリズムは概ねテンプレートとして提供されている(standard template library : STL)

## 11/18
### 15.4 スタックとキュー
リストより機能制限をし，余計な操作を封じたり，効率よく実装したり
- FIFO(先入先出)のデータ構造を**キュー**という
	- FIFO-先に入れたデータが先に使われる
	- 行列をイミッジ
- LIFO(後入先出)のデータ構造を**スタック**という
	- LIFO-後に入れたデータが先に使われる
	- 積み上げられた書類をイミッジ
- キューやスタックは配列を工夫して使うことで実現することもできる
	- 最大サイズが決まってさえいれば別にリストを使って実装する必要はなく固定長配列を利用して作ることができる
- キューにはqueue, スタックにはstackという標準のクラステンプレートが用意されている
	- dequeを使って参照
	- queue : pushで末尾にデータ追加, frontで参照, popで削除, backで末尾データ取得, size/empty
	- stack : pushでデータを地番上に追加, topで参照, popで削除, size/empty

## 11/19
### 15.5 placement new
参考：http://d.hatena.ne.jp/toburau/20111128/1322503487
- new(アドレス)とすると，メモリを動的に確保せず，**指定したアドレスにあるメモリを使って**コンストラクタを呼ぶ **placement new**
	- new演算子をオーバーロードすることで実現(`operator*`とかとはまた振る舞いがちがう)
```
char* memory = operator new( sizeof(char) * 10 );
//memoryのアドレスに対してオブジェクトの領域を確保
char* p = new( memory ) char[10];
//開放は普通にdeleteで
operator delete( memory );
```
- placement newを使って初期化されたオブジェクトを破棄する場合，直接デストラクタを呼ぶ
- オーバーロードされたnew演算子を使う場合，operator new が呼ばれた後にコンストラクタが呼ばれる
- operator new/delete を直接呼ぶとコンストラクタやデストラクタは呼ばれない
- 自分でこういう書き方をすることはあまりないらしい...

## 15.6-15.8 再帰関数
特殊な（？）データ構造を扱うために必要なテクニック
- 自分自身を呼ぶ関数を再帰関数という
- 終了条件をきちんとしないと再帰関数は**無限ループ**になる可能性あり
- あまり多く再帰するとstack overflowを起こすことあり
- 再帰関数を考えるコツは，一旦再帰関数であることを**忘れてしまう**こと
- 再帰関数では**引数**を使って状態を少し変えて引き継ぐことができる
- 再帰関数では**戻り値**を使って結果を少し変えて引き継ぐことができる(Σとか便利)
- 実現したい処理が自分自身なら自分自身を呼べばいい
- **ワイルドカード**というのは，任意の０文字以上のもの．`"*.txt"`は任意のテキストファイル


## memo
- 15.1のプログラムはややこしい．メンバポインタとかいろいろと発展的な内容な気がするのでよく復習した方がよさげ．
- typedef,TYPE忘れてる.
