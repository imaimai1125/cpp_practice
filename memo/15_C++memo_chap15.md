## chapter.15 データ構造
- 今までは配列だけだったけど，リスト，スタック，キュー，ツリー，ハッシュ表とかのデータ構造を学ぶ
- 状況に応じていろいろなデータを使い分けることで処理効率が上がったりする

- 15.1 単方向リスト
- 15.2 双方向リスト
- 15.3 イテレータとアルゴリズム
- 15.4 スタックとキュー
- 15.5 placement new
- 15.6-15.8 再帰関数
- 15.9 ツリー
- 15.10 二分木探索
- 15.11 ハッシュ

## 11/17
### 15.1 単方向リスト	
- リストはポインタを介してデータを数珠つなぎしたもの
- リストは配列とは異なり，要素の**挿入や削除が簡単**
- その代わりリストは**インデックスの参照が不得意**

### 15.2 双方向リスト
- 次のノードへのポインンタのみを持つリストをたん方向リストという
	- 指定したノードではなくて，その次のノードを削除するという形にしてあった（不自然）
- 加えて**前の**ノードへのポインタを持つリストを双方向リストという
	- 挿入の際に前後のノードポインタを変更する必要があるけれども，便利にはなる
- リストの端は
	- NULL
	- 端をあらわすダミーのノードをつくる（m_eolなど)
- 代表的なlist関数:**p797-800**
	- T& front/back, resize(size), clear(), empty(), iterator begin/end()
	- iterator insert(), iterator erase() など．．

### 15.3 イテレータとアルゴリズム
リストはノード構造体のメンバに直接アクセスすることでループをしていた
．今回はもっと感覚的に
- ポインタのように扱えるクラスのことをイテレータという
- listヘッダにはリストを扱うクラステンプレート list　が定義されている
- algorithm ヘッダにはイテレータを扱ういろいろな関数テンプレートが定義されている
```
//こっちのほうがわかりやすい	
static void GoNext(Node*& node){
	node node->next;
}
Node::GoNext(node);
```
- こういうノードの処理をラップしたクラスを作れる
- イテレータを扱うことのできる関数テンプレートが標準でいくつも用意されてる--**algorithmライブラリ**
	- fill_n, copy, copy_backward, sort, stable sort, find_if, binary_search, random_shuffle　など
- vectorやlistといったクラステンプレートは複数のデータを統括して使う物(**container**)　
	- コンテナを扱うためのアルゴリズムは概ねテンプレートとして提供されている(standard template library : STL)

### 15.4 スタックとキュー
リストより機能制限をし，余計な操作を封じたり，効率よく実装したり
- FIFO(先入先出)のデータ構造を**キュー**という
	- FIFO-先に入れたデータが先に使われる
	- 行列をイミッジ
- LIFO(後入先出)のデータ構造を**スタック**という
	- LIFO-後に入れたデータが先に使われる
	- 積み上げられた書類をイミッジ
- キューやスタックは配列を工夫して使うことで実現することもできる
	- 最大サイズが決まってさえいれば別にリストを使って実装する必要はなく固定長配列を利用して作ることができる
- キューにはqueue, スタックにはstackという標準のクラステンプレートが用意されている



## memo
- 15.1のプログラムはややこしい．メンバポインタとかいろいろと発展的な内容な気がするのでよく復習した方がよさげ．
- TYPE忘れてる
