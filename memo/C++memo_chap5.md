##Chapter 5
###10/21
配列・構造体を詳しく。その他種種の概念

- 5.1, 5.2 配列
- 5.3-5.5 構造体 struct
- 5.6 列挙 enum
- 5.7 条件演算子 ?:
- 5.8 デフォルト変数	
- 5.9 静的ローカル変数
-　5.10 変数の寿命とスコープ
- 5.11 リンケージ
- 5.12 分割コンパイル
- 5.13 文字列リテラル
- 5.14 エスケープリンケージ
- 5.15-17 new & delete

### 5.1, 5.2 配列
- 配列の配列を作るときは[]の数を増やせばよい
- 配列の配列は指数乗にメモリが増えるので注意
-　int n[3][5]　で n[1] とすると &n[1][0] と同義
- 配列を宣言するときにはじめの部分だけは省略できる
```
n[][] = {
	{1,2,3,4,5},
	{6,7,8,9,10},
	{11,12,13,14,15},
};
```
はビルドエラー
```
n[][5] = {
	{1,2,3,4,5},
	{6,7,8,9,10},
	{11,12,13,14,15},
};
```
はきちんと機能する。

### 5.3-5.5 構造体 struct
- 構造体の宣言の書式は ```struct タグ名　{変数宣言郡};```
- 構造体を使うことで関連のある変数をひとまとめに扱える
- 構造体の宣言は**型宣言**である
- 構造体の各変数はメンバという
- メモリ上にある変数を実体（インスタンス）と、構造体変数のことをオブジェクトとも言う。
- メンバを使うときは```object.member```.これで操作ができる。

- オブジェクトの初期化子は{}で囲む
- 構造体は主に**参照渡し**
- ポインタでメンバにアクセスすることも可能 ```->```を使う

### 5.6 列挙 enum
- ```enum 型{名前　= 値, 名前 = 値, ... ,};```で列挙
- 列挙体変数へは列挙体系の値しか代入できない
- enumの中身は必ず最後でも, を付ける
- 列挙子は整数定数としても利用できる(true = 1, false = 0 みたいなもの)
- 列挙子は初期値が前の数+1
- 一番初めの列挙子は初期値0
- 列挙体変数の値の保障は自分で持つこと
-　enum型でキャストするとどんな値でも扱える。これは致命的な穴らしい。**(が、実際なんで穴なのかよくわからん)**
- enum型はフラグを宣言するときによく使う。フラグとは、状態や設定を表す値
- 列挙体にはコンマを付けてはいけない。

### 5.7 条件演算子 ?:
- conditional operator ?
- ```条件式? 真の場合:偽の場合```
- ```(a>b ? a:b)``` a>bが真の場合はa,偽の場合はbを返す

### 5.8 デフォルト変数	
-　仮引数を初期化するような形にすると省略したときその値が使われる
-　これをデフォルト引数という
-　途中の引数だけを省略することはできない
- デフォルト引数には性的なデータしか指定できない
- オーバーロードとデフォルト引数を併用するときは、呼び出しが区別できるかどうかに注意する
```
sum(int a, int b, int def = 1){
	return a+b+def
}
```
みたいな設定ができる。


### 5.9 静的ローカル変数
- staticを付けることでローカル変数が静的に
- staticのついていない変数は**自動変数**という。
- 自動変数のアドレスを返すような関数はつくっちゃだめ！
- 静的変数の初期化は1度のみ
- 宣言しなければ初期化の値は0
- 静的関数は関数を抜けても値が保存される
- global変数は静的関数

###10/22

###　5.10 変数の寿命とスコープ
- 変数の有効期間を寿命という
- {}で囲んだ全体をブロックという
- 変数や関数の見える範囲をscopeという
- 変数の寿命はスコープによって決まる
- スコープが違えば同じ名前の別の変数を作ることができる
- ::を付ければどのスコープからでもグローバル変数をさせる



### 5.11 リンケージ
### 5.12 分割コンパイル
### 5.13 文字列リテラル
### 5.14 エスケープリンケージ
### 5.15-17 new & delete
