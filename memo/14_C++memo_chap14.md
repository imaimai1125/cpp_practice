## chapter.14 もっともっと深く
クラスとは関係が浅い事項に関すること


- 14.1 ショートサーキット
- 14.2 voidへのポインタ
- 14.3-14.4 if
- 14.5 組み込みマクロ
- 14.6 可変個引数
- 14.7 mainの戻り値
- 14.8 コマンドライン引数
- 14.9 強制終了
- 14.10 アラインメント
- 14.11 プリコンパイル済みヘッダファイル

## 11/13 p720-
### 14.1 ショートサーキット		
- もとからC++に備わっている仕様
- 条件式は真か偽かが判明したところですぐに判定を終了する．
	- 人間は鳥であり，かつ人間は虫である．
	- 人間は鳥である，**かつ**で終了したい->ショートカットサーキット
- ショートカットサーキットが原因で起こってしまうバグだってある
- 省略された条件内の関数は呼ばれない


### 14.2 voidへのポインタ
voidに*をつけるとどうなるの？？？
- voidへのポインタにはほとんどのポインタをキャストなしで代入できる
- voidへのポインタからは直接は参照先にアクセスできない
- voidへのポインタから他のポインタへの代入にはキャストが必要	
- voidへのポインタは型を不問でアドレスを受け取る引数に使う

## 11/14 p728-
### 14.3-14.4 #if
- `#if 条件式 〜 #endif`でコンパイルするかどうかを制御できる
	- `#`は前処理命令と言って，コンパイルする前にいろいろと操作するための命令
	- `#if`のあとの条件式が真のときのみ`#endif`までコンパイルせよということ
- 定義されているかの評価は`defined(名前)`で行える．`#if`特有の演算子
- マクロが定義されているかどうかの分岐には`#ifdef`とか`#ifndef`とかが用意されている
	- 二重インクルード防止のときとかに使った(if defined / if not defined)
- elseやelse if に対応するものとして`#else`とか`#elif`がある
- `#if`の条件式にはコンパイル前に決まる値しか使うことができない
- `#error`を使うと強制的にコンパイルエラーを出すことができる．
```
//DEBUGのつぎに書いた文はデバッグ時にのみ実行
#ifdef NDEBUG
#define DEBUG if(true){}
#else
#define DEBUG is (false){}
#endif
...

DEBUG Hoge(1,2);
//↑はデバッグ時にしか実行されない
```

## 11/15 p745-
### 14.5 組み込みマクロ
12.13節のassertマクロを自作してみる
- `_FILE_`はファイル名，`_LINE_`は行番号に置き換わる
	- これがマクロ定義内出会っても，展開先の情報で展開される

- 組み込みマクロの種類
	- `__FILE__` : ファイル名を表す文字列リテラル
	- `__LINE__` : 行番号を示す10進定数
	- `__DATE__` : 現在のソースファイルをコンパイルしたときの日付を表す文字列リテラル
	- `__TIME__` : 現在のソースファイルをコンパイルしたときの時刻を表す文字列リテラル
	- `__cplusplus__` : C++のコンパイラでコンパイルされた場合に定義される
	- `__STDC__` : これが定義されているかどうかと，定義され値た場合のその値は処理系定義

### 14.6 可変個引数
- 引数の部分を...にすればいくらでも引数が取れる
- va_list型の変数とva_start, va_arg, va_endマクロで可変個引数を扱える
- 注意３つ
	- 可変個引数に渡す際，必ず元の型が保存されないという点 : 引数に渡したchar値とshort値はint値に，float値はdouble値にそれぞれ自動的に拡張される
	- 可変個引数に渡されてきた値の型や引数の数は取得できない : 可変個引数の個数は言語的にはどうやっても取得できないので関数を使う人が注意すべき
	- ポインタの扱い : NULL pointer は必ず適切なポインタ型にキャストしてから渡す．

```
void PrintF(const char* format,...){
	va_list args;
	va_start(args,format);
	vprintf(format, args);
	va_end(args);
}
```

### 14.7 mainの戻り値

  


## memo 
- assertマクロ覚えてないな。再チェックしよう
- 変数とスタック：自動変数や引数はスタックというメモリ領域に作られる．引数は**最後の引数から順番に**スタックに積まれていく．一番最初の引数がスタックに積まれたあとにかん数から戻るときに**ジャンプする位置のアドレス（return address)をスタックに積んで関数へとジャンプする**．こうすると，スタックの一番↑にはリターンアドレスがあり，そのつぎに積まれているものが一番最初の引数だとわかる．そしてそのつぎのメモリ領域からがかへの引数のメモリ領域であるとわかる
- va_start買う路はこの可変個引数のメモリ領域の先頭アドレスをva_list型の変数にセットする．



