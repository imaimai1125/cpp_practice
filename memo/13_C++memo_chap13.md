## chapter.13 もっともっと深く
発展的な内容（クラスを使うことメイン）
## 11/6 p628-

- 13.1-13.2 多重継承
- 13.3-13.5 仮想継承
- 13.6 インターフェースクラス
- 13.7 typeid演算子とtype_info
- 13.8 ダウンキャストとクロスキャスト
- 13.9 フレンド
- 13.10 不完全型
- 13.11 using
- 13.12 その他のテンプレート引数
- 13.13 テンプレートの特殊化
- 13.14 関数ポインタ
- 13.15-13.16 メンバ関数ポインタ
- 13.17 メンバ変数ポインタ

### 13.1-13.2 多重継承
- 2つ以上のクラスを継承することを多重継承という
- 複数の機能の共通部分を表現する基底クラスを用意して、その基底クラスへのポインタや参照を使って汎用的な処理を記述して於けば、その処理は具体的な機能が記述されたあらゆる派生クラスに対して汎用的に使える
- 特定の機能を持ったクラスを作る必要がある場合には機能に対応する基底クラスを継承し、仮想関数をそのクラスに合わせてoverrideするだけで良い

- 一度に同じクラスを直接2つ以上継承することはできない
- 間にクラスを挟めば同じクラスを2つ以上継承することもできる
	- その場合仮想関数をオーバーライドしようとするとすべての仮想関数が同じ形でオーバーライドされる
- アップキャスト先が曖昧になる場合は曖昧にならないところへと一旦アップキャストする。

##11/7 p640-
### 13.3-13.5 仮想継承
- 同じクラスを複数継承した場合、その**全て**にメンバ変数が作られる 
- 仮想継承されたクラスは**同時に複数継承されなくなる**
- 継承するときには```virtual```をつければ仮想継承できる
- 仮想継承されたコンストラクタは2つ以上先の派生クラスでも呼ぶ必要がある
	- 基底クラスのメンバ変数が共有されるので、多重継承のまま初期化すると2回初期化してしまうことになる。
- 仮想継承されたクラスの仮想関数の実装は同時に**1種類**しか存在してはいけない（大元が1個だけということ）
- 仮想継承のときはクラスが**経路依存**しなくなる
- 仮想継承されたクラスの参照へは直接アップキャストできる
- A1,A2（ともにCの基底クラス）でAHoge()という関数がオーバーライドされている場合、必ずCでもAHoge()オーバーライドする必要がある。


### 13.6 インターフェースクラス
- **仮想デストラクタ以外には純粋仮想関数しか存在しない**クラスをインターフェースクラスということがある
	- どんな関数を持つかというインターフェースだけを提供するクラス
- インターフェースクラスを仮想継承した場合は多重継承における面倒な問題がほとんど**発生しない**


### 13.7 typeid演算子とtype_info
- typeid演算子で型情報を取得できる
```
void ShowType(const ostream& ostr){
	cout << typeid(ostr).name() << endl;
}
```
- 実行時に得られる型情報のことをRTTI(Run-Time Type Information)という
- 型情報はtype_infoクラスへのconst参照として取得できる
- nameで型名を（何らかの形で）取得できる
- 型情報を得るときには**トップレベルのconstや参照は無視**される
	- 参照先ではなく変数自身をconstにするタイプのconstのこと


### 13.8 ダウンキャストとクロスキャスト
- 派生クラスへのポインタ型や参照型へとキャストすることをダウンキャストという
	- 本来の型とは無関係なクラスへとダウンキャストされてしまう可能性があり、危険
	- キャストしてはいけない型へとキャストしてしまう可能性あり。
- dynamic_castを使えばキャスト時に継承関係をチェックしてくれる
	- ダウンキャスト可能かどうか自動的に判定してくれる便利なキャスト演算子
	- 不当なキャストの時は、ポインタ型の場合はNULLを返し、参照方の場合はbad_cast例外を投げる
- istream->iostream->ostream とかは上がって下がる**クロスキャスト**
	- dynamic_castはこのようなキャストを直接行うことができる
	- かつクロスキャスト可能かどうかもチェックしてくれる
- ダウンキャスト、クロスキャストは危険なのであまり使うべきではない。

### 13.9 フレンド
- フレンドの関係にあればアクセス指定を無視できる
- フレンドにはクラスも関数も指定できる。
	- クラス内の特定のメンバ関数だけでも指定可能。
- クラスの名前だけを宣言することもできる
- フレンド指定は**一方通行**

## 11/8
### 13.10 不完全型
- ```class クラス名;```とすれば不完全型を宣言できる
- クラスの具体的な内容を知る必要がない場合は不完全型で十分
- クラスの具体的な内容を知る必要がある場合はクラスの完全な宣言が必要になる
- 不完全型は**2つのクラスが相互参照している場合**によく使われる。
- 関数プロトタイプに似ている

### 13.11 using
- ``` using namespace 名前空間名; ```とするとその名前空間内の識別子名がすべて現在の**スコープ内に取り込まれる**
- ```using 識別子名;```とすると識別子のみが現在のスコープ内に取り込まれる 
- using宣言は基底クラスの関数を派生クラスで使用できるようにする場合にも使われる
	- スコープ解決を省略できるということなのかな？
	- includeとかとの住み分けは？？
	- 継承関係があるときだけこの方式は使える（13_11_Using2.cpp)

### 13.12 その他のテンプレート引数
- typename以外の引数もある
- テンプレート引数にクラステンプレートを取ることが出きる
- テンプレート引数には静的な整数定数やポインタをとることができる
```
template <template<typename,typename> class TEMPL>
 class Hoge
{
public:
	void Run(){
		m_v.push_back(1);
		m_v.push_back(5.2);
		for (size_t i = 0, size = m_v.size() ; i < size; ++i){
			cout << m_v[i] << " ";
		}
		cout << endl;
	}
private:
	TEMPL<double ,allocator<int> >  m_v;
};

int main(){
	//vectorを指定してやる
	//vector<double, allocator<int> >型のメンバ変数m_vを宣言していることになる。
	Hoge<vector> hoge;
	hoge.Run();
}
```
```

template<int N>
 class SBit
{
public:
	static const int Value = 1 << N;
};

int main(){
	/**********************************************
	関数は動的なのでarrayに打ち込むのは無理だけど、
	こいつは静的なのでぶち込める
	マクロでもぶち込めるようなものを作ることは可能
	#define BIT(x) (1<<(int)x)
	**********************************************/
	int array[SBit<5>::Value];
}
```


### 13.13 テンプレートの特殊化
- クラステンプレートは特定の値に特化した実装を定義することができる**（特殊化）**
- クラステンプレートは部分的に特化した実装を定義することができる**（部分特殊化）**
```
template<typename TYPE1>
 class Hoge<TYPE1, int>{};
 //この場合、第二テンプレート引数だけを特殊化している。
```

```
template<typename TYPE>
 class Hoge<TYPE,TYPE*>{...};
 などもできる。
```
- 関数テンプレートは特殊化可能だが部分特殊化不可能。ただし**オーバーロード**で代用できる。
- climitsヘッダでは、INT_MAX,INT_MIN, USHRT_MAXなどの最大・最小のマクロが定義されている
	- CHAR_BITなどという1ばいとのビット数を記述するマクロもある
- cfloatヘッダでは、浮動小数点型の最小値,最大値のマクロがある
	- float : FLT_ , double : DBL_ , long double : LDBL
- pairは、2つの方の異なる値をまとめて管理するクラステンプレート。
	- utilityヘッダをインクルードする必要あり
```
namespace std{
	template<typename T1, typename T2>
	struct pair{
		typedef T1 first_type;
		typedef T2 second_type;
		T1 first;
		T2 second;
	}
}
```

## 11/9
### 13.14 関数ポインタ

### memo 
- インターフェースクラスっていみあるの？
	- 整理用に使うだけ？
- アップキャストとダウンキャストは全然種類が違うきがするなぁ。
- テンプレートの使い方、イマイチわかってないので復習しておかないといけない。（Chapter9）