##Chapter 4 ポインタ天国
高級言語と低級言語を分かつすごいやつ
###10/20
### 4.1メモリ町一番地：メモリとアドレス
- メモリは使用中のデータをおいておくところ
- 基本的にメモリ上の位置のことをアドレスという
- アドレスは普通の変数の場合は前に**&**を付けることで配列変数と関数の場合はその名前を書くことで取得できる（参照渡し）
-　メモリ：一時的な保管場所　ディスク：永久に保存
- 値のアドレスを確認するとき>>関数を初期化する前に```cout``` 数値には前に&をつける、関数と配列はただたんに```cout```

#### 4.2,4.3　ポインタの代入
- アドレスに*を付けるとそのアドレスにあるメモリを扱える
- 参照とポインタの違い：参照は一度参照先を決めたら二度と変えられない。ポインタはアドレスを再代入すれば何度でも参照先を変えられる
- 関数内の引数に*を付けてポインタを宣言
- ```int* p,q```では、pだけポインタになる。

###　4.4,5
 配列再考
-　配列変数はメモリ上に**連続して**存在している(メモリ上の占有数は時と場合による。intが4バイトなのであればメモリスペースを4つ確保。)
- 配列変数を引数に取るときは、配列変数の先頭要素のアドレスを渡し、ポインタで受ける
- ポインタも配列変数と同じく[]で各要素を参照できる
- 関数宣言の中は配列の大きさを指定する必要はない
- 配列変数はポインタを表しているので、参照渡しをしている。n[]の場合、Func(n)とFunc(&n[0])は同等
- ポインタと配列の違い
	- 配列をポインタに代入はできるけれど（参照渡しだから）、**ポインタは配列に代入できない**（ポインタは配列ではない）
	- ポインタは参照を渡しているだけなので、sizeofでとってきても先頭の大きさになる。

###4.6 アドレスの演算【1】
- 配列のある要素のアドレス```&n[i]+1```を行うと、その数だけ進んだ要素のアドレス**&n[i+1]**になる。配列上のメモリに加算がされる
- 2つの配列要素のアドレス```&n[i]-&n[j]```を行うと**i-j**が得られる。
- アドレス同士の引き算はできるけど、アドレス同士の足し算はできない（というかそれをする意味がない）
- アドレスは乗算除算はできないことになってる（やりたければcastしてください）


### 4.7　アドレスの演算【2】　配列とポインタ
- *と[]は同じ効果を持つ演算子
-　*(str + i)はstr[0]のアドレスにiを加えたもの。つまりstr[i] 

### 4.8,4.9 const
- ポインタ型や参照型の前に```const```を付けると参照先の値を変更できなくなる。
- ```const char* str``` みたいに使う
- ポインタの前にconstを付けた場合ポインタ**先**の変数が定数になる。
- ポインタの値は変更できるが、*strやstr[i]とかは参照先なので変更できない
```
//constの書式(参照先の固定)
const 型　名前　= 初期値;
//ポインタ自身を定数にする場合
型* const 変数名　= 初期値;
```
- const自体も型の一部
- 関数内でconstにすると関数内での書き換え不可。
- constを使って作られる定数「表意定数,figurative constant」
- 生の値を直接埋め込む**「マジックナンバー」**←非推奨

■constをポインタに付ける意味がいまいちわからない。参照している値にconstするのとどう違うの？

### 4.10　null pointer
- ヌルポインタはどんな変数や関数のアドレスと比較しても等しくならない
- ヌルポインタはソース上では0
- ヌルポインタにはNULLマクロを使える
- ヌルポインタは何らかのしるしの代わりに使える
- ポインタに0もしくはNULLを代入することで実現
 