## chapter.12 もっともっと高く
発展的な内容（クラスを使うこと以外の発展的な内容）
## 11/5 p566-
- 12.1-12.3  ビット演算
- 12.4-12.5 ビットフラグ
- 12.6 インライン関数
- 12.7 インラインメンバ関数
- 12.8-12.9 typedef
- 12.10 マクロ
- 12.11 マクロの使い方
- 12.12 マクロが原因のバグ
- 12.13 assertマクロ
- 12.14 デバッグモードとリリースモード

### 12.1-12.3 ビット演算 
- **AND**は論理積。```&```であらわす。
	- 特定のビットを取り出すときに使う
		- 消したいところのビットを0にした値を使って論理積にかけると良い（**masking**）
	- ビット演算子は四則演算とかに比べて優先順位が低い
		- 関係演算子（<=>など）よりも低い
		- 例外として NOT（```~```）は優先順位が高い
- **OR**は論理和。それぞれのビットについて両方共0のときは0，それ以外のときは1を出力
	- ORは```|```で表す
	- ORはビット合成するときに使う
- **XOR**は排他的論理和。それぞれのビットについて両方が同じ時は0、異なるときは1を出力
	- ORのうち、両方が重なるところを除外している
	- 特定のビットを**反転**させる時に用いられる
	- XORは```^```で表す
```
//プレイヤー切り替え 0 or 1
player ^= 1;
```
- **NOT**は論理否定。```~```で表す
	- 全ビットを反転する
- **ビットシフト** ```<<```もしくは ```>>```で表す。
	- 2の累乗の掛け算、割り算（及びあまり）に対応している。
	- 負の数を右シフトするとビットのなくなってしまうところが1で埋められる（算術シフト（環境依存）） 

- 補数（負の数）
	- 10を二進数で表すと(0001010)2となる
	- 補数は(11110110)2となる（反転して1をたす）

### 12.4-12.5 ビットフラグ（bool型のようなもの）
ビット演算の花型

- ビットフラグは```OR```で**つなぐ**
- ビットフラグは```AND```で**判定**する
- ビットフラグは```OR```で**合成・追加**できる
- ビットフラグは```NAND```で**削除**できる
- ビットフラグは```XOR```で**反転**できる

```
#include <iostream>
using namespace std;

int Bit(int x){
	return 1 << x;
}

//それぞれの記号の反転器
const int SHOW_X = Bit(0);
const int SHOW_Y = Bit(1);
const int SHOW_Z = Bit(2);
//結果を表示
void Show(int flags){
	cout << ((flags & SHOW_X) != 0 ? "X" :"x")
		 << ((flags & SHOW_Y) != 0 ? "Y" :"y")
		 << ((flags & SHOW_Z) != 0 ? "Z" :"z")
		 << endl;
}
int main(){
	//Showの引数はどのビットが立つかを記述している。
	//ひとけた目がX...となっている
	Show(1);
	Show(SHOW_X);
	Show(SHOW_X|SHOW_Z);
	Show(SHOW_X|SHOW_Y|SHOW_Z);
}
```

### 12.6 インライン関数
- 関数を呼ぶには時間がかかる
	- その関数が置かれているメモリ上の場所に移動しなければいけない
	- 関数の中身を関数に埋め込んでいる
	- ```inline int func(){} ```とする。
- インライン関数はライン関数を使うと処理をその場所に埋め込める
- インライン関数は**ヘッダファイルで実装***する
- インライン関数は必ず展開されるとは限らない
	- 処理が重いものはコンパイルが自動判断して普通の関数にしちゃう
- インライン関数内の静的ローカル関数はすべての展開先で同一のものが作られる。

### 12.7 インラインメンバ関数
- メンバ関数もインライン関数にできる
- **クラスの宣言の中で実装**するとインライン関数になる。
	- この場合は```inline```と記述しなくてよい
```
class Fraction{
public:
	//分子の取得
	//クラス宣言時に実装
	double GetNumber() const{
		return m_numer;
	}
}
```
- テンプレートの場合に限りクラス宣言内で実装する人もいる
	-常にヘッダファイルに実装を書く必要があるので、クラス宣言内で実装してしまっても特に問題がない。

### 12.8 typedef
^ typedefを使うと型の同義語を作ることができる。